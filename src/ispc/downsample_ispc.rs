#[allow(non_camel_case_types,dead_code,non_upper_case_globals,non_snake_case,improper_ctypes)]
pub mod downsample_ispc {
/* automatically generated by rust-bindgen 0.61.0 */

#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct uint32_t2 {
    pub v: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_uint32_t2() {
    const UNINIT: ::std::mem::MaybeUninit<uint32_t2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uint32_t2>(),
        16usize,
        concat!("Size of: ", stringify!(uint32_t2))
    );
    assert_eq!(
        ::std::mem::align_of::<uint32_t2>(),
        16usize,
        concat!("Alignment of ", stringify!(uint32_t2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uint32_t2),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Parameters {
    pub degamma: bool,
    pub gamma: bool,
}
#[test]
fn bindgen_test_layout_Parameters() {
    const UNINIT: ::std::mem::MaybeUninit<Parameters> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Parameters>(),
        2usize,
        concat!("Size of: ", stringify!(Parameters))
    );
    assert_eq!(
        ::std::mem::align_of::<Parameters>(),
        1usize,
        concat!("Alignment of ", stringify!(Parameters))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).degamma) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Parameters),
            "::",
            stringify!(degamma)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gamma) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Parameters),
            "::",
            stringify!(gamma)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct Image {
    pub data: *mut u8,
    pub __bindgen_padding_0: u64,
    pub size: uint32_t2,
}
#[test]
fn bindgen_test_layout_Image() {
    const UNINIT: ::std::mem::MaybeUninit<Image> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Image>(),
        32usize,
        concat!("Size of: ", stringify!(Image))
    );
    assert_eq!(
        ::std::mem::align_of::<Image>(),
        16usize,
        concat!("Alignment of ", stringify!(Image))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct FloatImage {
    pub data: *mut f32,
    pub __bindgen_padding_0: u64,
    pub size: uint32_t2,
}
#[test]
fn bindgen_test_layout_FloatImage() {
    const UNINIT: ::std::mem::MaybeUninit<FloatImage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FloatImage>(),
        32usize,
        concat!("Size of: ", stringify!(FloatImage))
    );
    assert_eq!(
        ::std::mem::align_of::<FloatImage>(),
        16usize,
        concat!("Alignment of ", stringify!(FloatImage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FloatImage),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FloatImage),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    pub fn resample(
        params: *const Parameters,
        src: *const Image,
        degamma: *mut FloatImage,
        dst: *mut Image,
        num_channels: u8,
    );
}
extern "C" {
    pub fn scale_to_alpha_coverage(
        source_width: u32,
        source_height: u32,
        source_data: *const u8,
        downsampled_width: u32,
        downsampled_height: u32,
        downsampled_image_data: *mut u8,
        alpha_cutoff: *const f32,
    );
}
}